function[Vres, Vmask]=projectVol(V,V_orig,surf,lower_surf,upper_surf,thickness,step,dir)
[wx,wy,wz]=size(V_orig);

%step=thickness*2;
dx=floor((wx-1)/step);
dy=floor((wy-1)/step);

%project bounded subvolume from original volume to result volume
if(strcmp(dir,'direct')~=0) 
    Vmask=0;
    Vres=zeros(wx,wy,thickness*2+1);
    %Vres=zeros(wx,wy,wz);
    for x=1:dx
        lx=(x-1)*step+1;
        rx=lx+step;
        for y=1:dy
          ty=(y-1)*step+1;
          by=ty+step;
%          [ptl_l,pbl_l,ptr_l,pbr_l]=make3DPoints(x,y,step,lower_surf);
%          [ptl_u,pbl_u,ptr_u,pbr_u]=make3DPoints(x,y,step,upper_surf);
          
          face_b=makeFace(x,y,step,lower_surf);
          face_o=makeFace(x,y,step,surf);
          face_t=makeFace(x,y,step,upper_surf);
          
          prisms=getPrismoids(face_b,face_t,face_o);
          if(~isempty(prisms))
              el=project_prism_direct(V,prisms,step,thickness);          
%          el=project_element_direct(V,ptl_l,pbl_l,ptr_l,...
%              pbr_l,ptl_u,pbl_u,ptr_u,pbr_u,step,thickness);
          
              Vres(lx:rx-1,ty:by-1,:)=el;
          end;
        end;
    end;    
else  %project subvolume to bounded subvolume in original volume.
    Vres=V_orig;
    Vmask=0*Vres;
    for x=1:dx
        lx=(x-1)*step+1;
        rx=lx+step;
        for y=1:dy
          ty=(y-1)*step+1;
          by=ty+step;
          [ptl_l,pbl_l,ptr_l,pbr_l]=make3DPoints(x,y,step,lower_surf);
          [ptl_u,pbl_u,ptr_u,pbr_u]=make3DPoints(x,y,step,upper_surf);

          face_b=makeFace(x,y,step,lower_surf);
          face_o=makeFace(x,y,step,surf);
          face_t=makeFace(x,y,step,upper_surf);
          prisms=getPrismoids(face_b,face_t,face_o);
          
          %volume boundary.
          btl_l=min([ptl_l;pbl_l;ptr_l;pbr_l;ptl_u;pbl_u;ptr_u;pbr_u]);
          bbr_u=max([ptl_l;pbl_l;ptr_l;pbr_l;ptl_u;pbl_u;ptr_u;pbr_u]);
          btl_l=atb(floor(btl_l),[wx,wy,wz],3);
          bbr_u=atb(ceil(bbr_u),[wx,wy,wz],3);
          [el,el_mask]=project_prism_reverse(V,prisms,step,thickness);
          if(~isempty(prisms))
          end;
          
          if(ptl_u(3)>1 || pbl_u(3)>1 || ptr_u(3)>1 || pbr_u(3)>1 || ...
                  ptl_u(3)>1 || pbl_u(3)>1 || ptr_u(3)>1 || pbr_u(3)>1)              
              [el,el_mask]=project_element_reverse(V,V_orig,ptl_l,pbl_l,ptr_l,...
                  pbr_l,ptl_u,pbl_u,ptr_u,pbr_u, btl_l, bbr_u, step,thickness);
              Vres(btl_l(1):bbr_u(1),btl_l(2):bbr_u(2),btl_l(3):bbr_u(3))=el;             
    	      Vmask(btl_l(1):bbr_u(1),btl_l(2):bbr_u(2),btl_l(3):bbr_u(3))=el_mask;
          end;
        end;
    end;    
end;
    
function [face] = makeFace(x,y,step,surf)
lx=(x-1)*step+1;
rx=lx+step;
ty=(y-1)*step+1;
by=ty+step;
vert(1,:)=[lx,ty,surf(3,x,y)];
vert(2,:)=[rx,ty,surf(3,x+1,y)];
vert(3,:)=[rx,by,surf(3,x+1,y+1)];
vert(4,:)=[lx,by,surf(3,x,y+1)];
face.vert=vert;
deg=ones(4,1);
for(i=1:4) 
   if(vert(i,3)~=1) deg(i)=0;end;
end;
face.deg=deg;
face.ndeg=sum(deg);

function [pr] = makePrismoid(face_b,face_t,ind)
for i=1:3
    bt(i,:)=face_b.vert(ind(i),:);
    tp(i,:)=face_t.vert(ind(i),:);
end;
pr.bt=bt;
pr.tp=tp;
pr.ind=ind;

function [pr] = makeRegularPrismoid(ind,origin,step,thickness)
lx=origin(1);ty=origin(2);rx=origin(1)+step-1;by=origin(2)+step-1;
nzmax=thickness*2+1;

ptl(1,:)=[lx,ty,1]; ptu(1,:)=[lx,ty,nzmax];
ptl(2,:)=[rx,ty,1]; ptu(2,:)=[rx,ty,nzmax];
ptl(3,:)=[rx,by,1]; ptu(3,:)=[rx,by,nzmax];
ptl(4,:)=[lx,by,1]; ptu(4,:)=[lx,by,nzmax];

for i=1:3
    pb(i,:)=ptl(ind(i),:);
    pt(i,:)=ptu(ind(i),:);
end;
pr.bt=pb;
pr.tp=pt;
pr.ind=ind;
    
    
function [prisms] = getPrismoids(face_b,face_t,face_orig)
if(face_orig.ndeg>1) prisms=[]; return; end;
deg=face_orig.deg;
if(face_orig.ndeg==1) %one vertex is degenerate, exclude containing prismoid
    if(deg(1)==1) ind=[2,3,4];
    elseif(deg(2)==1) ind=[3,4,1];
    elseif(deg(3)==1) ind=[4,1,2];
    else ind=[1,2,3];
    end;
    prisms(1)=makePrismoid(face_b,face_t,ind);
else %regular case.
    prisms(1)=makePrismoid(face_b,face_t,[1,2,3]);
    prisms(2)=makePrismoid(face_b,face_t,[3,4,1]);
end;

function [tl, bl, tr, br]=make3DPoints(x,y,step,surf)
lx=(x-1)*step+1;
rx=lx+step;
ty=(y-1)*step+1;
by=ty+step;
tl=[lx,ty,surf(3,x,y)];
bl=[lx,by,surf(3,x,y+1)];
tr=[rx,ty,surf(3,x+1,y)];
br=[rx,by,surf(3,x+1,y+1)];


function[tetra]=reg_prism_partition(prism,step,thickness,origin)
nzmax=thickness*2+1;
lx=origin(1);ty=origin(2);rx=origin(1)+step-1;by=origin(2)+step-1;
ptl(1)=[lx,ty,1]; ptu(1)=[lx,ty,nzmax];
ptl(2)=[rx,ty,1]; ptu(2)=[rx,ty,nzmax];
ptl(3)=[rx,by,1]; ptu(3)=[rx,by,nzmax];
ptl(4)=[lx,by,1]; ptu(4)=[lx,by,nzmax];
ind=prism.ind;
for i=1:3
    pb(:,i)=ptl(ind(i),:);
    pt(:,i)=ptu(ind(i),:);
end;

ntl_l=[lx,ty,1];ntl_u=[lx,ty,nzmax];ntr_l=[rx,ty,1];ntr_u=[rx,ty,nzmax];
nbr_l=[rx,by,1];nbr_u=[rx,by,nzmax];nbl_l=[lx,by,1];nbl_u=[lx,by,nzmax];
tetra=tetrahedron_partition(ntl_l,nbl_l,ntr_l,nbr_l,ntl_u,nbl_u,ntr_u,nbr_u);

function[tetra]=cuboid_tetrahedron_partition(step,thickness,origin)
nzmax=thickness*2+1;
lx=origin(1);ty=origin(2);rx=origin(1)+step-1;by=origin(2)+step-1;
ntl_l=[lx,ty,1];ntl_u=[lx,ty,nzmax];ntr_l=[rx,ty,1];ntr_u=[rx,ty,nzmax];
nbr_l=[rx,by,1];nbr_u=[rx,by,nzmax];nbl_l=[lx,by,1];nbl_u=[lx,by,nzmax];
tetra=tetrahedron_partition(ntl_l,nbl_l,ntr_l,nbr_l,ntl_u,nbl_u,ntr_u,nbr_u);

function [Vres,Vmask]=project_element_reverse(V,V_orig,ptl_l,pbl_l,ptr_l,...
                  pbr_l,ptl_u,pbl_u,ptr_u,pbr_u, btl_l, bbr_u, step,thickness)
sz=size(V);
nzmax=thickness*2+1;
tetra_old=cuboid_tetrahedron_partition(step,thickness,[ptl_l(1),ptl_l(2)]);
tetra_new=tetrahedron_partition...
    (ptl_l,pbl_l,ptr_l,pbr_l,ptl_u,pbl_u,ptr_u,pbr_u);
mx=bbr_u-btl_l+[1,1,1];

Vres=V_orig(btl_l(1):bbr_u(1),btl_l(2):bbr_u(2),btl_l(3):bbr_u(3));
Vmask=0*Vres;

bound_low=[ptl_l(1),ptl_l(2),1];
bound_high=bound_low+[step,step,nzmax];
%main cycle.
for z=1:mx(3)
    for y=1:mx(2)
        for x=1:mx(1)
            pt=[x,y,z]+btl_l-[1,1,1];                 
            t=get_containing_tetrahedron(pt,tetra_new);
            if(t<1)
                continue;
            end;
            
            x_old=round(coord_transform(pt,tetra_new(t),tetra_old(t)));

            %test reverse transform            
            x_old1=atb_l(x_old,bound_low,bound_high,3);
            if(norm(x_old1-x_old)>0) %should not happen
                continue;
            end;
            val=V(x_old1(1),x_old1(2),x_old1(3));        
            Vres(x,y,z)=val;
	    Vmask(x,y,z)=255;
        end;
    end;
end;

function [Vres,Vmask]=project_prism_reverse(V,V_orig,ptl_l,pbl_l,ptr_l,...
                  pbr_l,ptl_u,pbl_u,ptr_u,pbr_u, btl_l, bbr_u, step,thickness)
sz=size(V);
nzmax=thickness*2+1;
tetra_old=cuboid_tetrahedron_partition(step,thickness,[ptl_l(1),ptl_l(2)]);
tetra_new=tetrahedron_partition...
    (ptl_l,pbl_l,ptr_l,pbr_l,ptl_u,pbl_u,ptr_u,pbr_u);
mx=bbr_u-btl_l+[1,1,1];

Vres=V_orig(btl_l(1):bbr_u(1),btl_l(2):bbr_u(2),btl_l(3):bbr_u(3));
Vmask=0*Vres;

bound_low=[ptl_l(1),ptl_l(2),1];
bound_high=bound_low+[step,step,nzmax];
%main cycle.
for z=1:mx(3)
    for y=1:mx(2)
        for x=1:mx(1)
            pt=[x,y,z]+btl_l-[1,1,1];                 
            t=get_containing_tetrahedron(pt,tetra_new);
            if(t<1)
                continue;
            end;
            
            x_old=round(coord_transform(pt,tetra_new(t),tetra_old(t)));

            %test reverse transform            
            x_old1=atb_l(x_old,bound_low,bound_high,3);
            if(norm(x_old1-x_old)>0) %should not happen
                continue;
            end;
            val=V(x_old1(1),x_old1(2),x_old1(3));        
            Vres(x,y,z)=val;
	    Vmask(x,y,z)=255;
        end;
    end;
end;

function [Vres]=project_prism_direct(V,prisms,step,thickness)
      
sz=size(V);
tetra_old(1:3)=prism_partition(prisms(1));
tetra_new(1:3)=prism_partition(makeRegularPrismoid(prisms(1).ind,[1,1],step,thickness));

if(size(prisms,2)>1)
    tetra_old(4:6)=prism_partition(prisms(2));
    tetra_new(4:6)=prism_partition(makeRegularPrismoid(prisms(2).ind,[1,1],step,thickness));
end;

nzmax=thickness*2+1;
Vres=zeros(step,step,nzmax);

%main cycle.
for z=1:nzmax
    for y=1:step
        for x=1:step
            t=get_containing_tetrahedron([x,y,z],tetra_new);
            if(t<1)
                continue;
            end;
            
            x_old=round(coord_transform([x,y,z],tetra_new(t),tetra_old(t)));
            x_old1=atb(x_old,sz,3);
%            if(norm(x_old1-x_old)>3)
%                x_old=x_old1;
%            end;
            val=V(x_old1(1),x_old1(2),x_old1(3));        
%            if(t==6) Vres(x,y,z)=255; %test
%            else
                Vres(x,y,z)=val;
%            end;
        end;
    end;
end;



function [Vres]=project_element_direct(V,ptl_l,pbl_l,ptr_l,pbr_l,...
          ptl_u,pbl_u,ptr_u,pbr_u,step,thickness)
      
sz=size(V);
tetra_old=tetrahedron_partition...
    (ptl_l,pbl_l,ptr_l,pbr_l,ptl_u,pbl_u,ptr_u,pbr_u);

nzmax=thickness*2+1;
tetra_new=cuboid_tetrahedron_partition(step,thickness,[1,1]);
Vres=zeros(step,step,nzmax);

%main cycle.
for z=1:nzmax
    for y=1:step
        for x=1:step
            t=get_containing_tetrahedron([x,y,z],tetra_new);
            if(t<1)
                continue;
            end;
            
            x_old=round(coord_transform([x,y,z],tetra_new(t),tetra_old(t)));
            x_old1=atb(x_old,sz,3);
%            if(norm(x_old1-x_old)>3)
%                x_old=x_old1;
%            end;
            val=V(x_old1(1),x_old1(2),x_old1(3));        
%            if(t==6) Vres(x,y,z)=255; %test
%            else
                Vres(x,y,z)=val;
%            end;
        end;
    end;
end;

function[t]=get_containing_tetrahedron(x,tetra)
t=-1;
ntetr=size(tetra,2);
for i=1:ntetr
    if(is_inside_tetrahedron(x,tetra(i))>0) t=i;return;end;
end;



function[tetra]=prism_partition(prism)
tetra(1)=tetrahedron(prism.bt(3,:),prism.bt(1,:),prism.bt(2,:),prism.tp(1,:));
tetra(2)=tetrahedron(prism.tp(2,:),prism.tp(1,:),prism.tp(3,:),prism.bt(3,:));
tetra(3)=tetrahedron(prism.tp(1,:),prism.tp(2,:),prism.bt(2,:),prism.bt(3,:));


function[tetra]=tetrahedron_partition...
    (ptl_l,pbl_l,ptr_l,pbr_l,ptl_u,pbl_u,ptr_u,pbr_u)
%partition begins
%front prismoid partition begins
%front tetrahedron
tetra(1)=tetrahedron(pbl_l,ptl_l,ptr_l,ptl_u);
%left tetrahedron
tetra(2)=tetrahedron(ptr_u,ptl_u,pbl_u,pbl_l);
%right tetrahedron
tetra(3)=tetrahedron(ptl_u,ptr_u,ptr_l,pbl_l);
%front prismoid partition ends
%rear prisomoid partition begins
%left tetrahedron
tetra(4)=tetrahedron(pbr_l,pbl_l,ptr_l,pbl_u);
%right tetrahedron
tetra(5)=tetrahedron(pbr_l,ptr_l,ptr_u,pbl_u);
%front(back) tetrahedron
tetra(6)=tetrahedron(pbl_u,pbr_u,ptr_u,pbr_l);
%rear prisomid partition ends
%partition ends

function[coefs]=plane_eq(x1,x2,x3)
cx=(x1(2)-x2(2))*(x3(3)-x2(3))-(x1(3)-x2(3))*(x3(2)-x2(2));
cy=(x1(3)-x2(3))*(x3(1)-x2(1))-(x1(1)-x2(1))*(x3(3)-x2(3));
cz=(x1(1)-x2(1))*(x3(2)-x2(2))-(x1(2)-x2(2))*(x3(1)-x2(1));
c0=(-x2(2)*x3(1)+x2(1)*x3(2))*x1(3)+(x2(3)*x3(1)-x2(1)*x3(3))*x1(2)+...
    (-x2(3)*x3(2)+x2(2)*x3(3))*x1(1);
coefs=-[cx,cy,cz,c0];
mx=max(coefs);
if(mx>0) coefs=coefs/mx; end;


function[res]=tetrahedron(x1,x2,x3,x4)
coefs=zeros(4,4);
base=plane_eq(x1,x2,x3);
left=plane_eq(x2,x4,x3);
right=plane_eq(x4,x2,x1);
rear=plane_eq(x1,x3,x4);
coefs(:,1)=base;
coefs(:,2)=left;
coefs(:,3)=right;
coefs(:,4)=rear;
res.faces=coefs;
res.origin=x2;
v1=x1-x2;v2=x3-x2;v3=x4-x2;
n1=norm(v1);n2=norm(v2);n3=norm(v3);

%if(n1>0)v1=v1/n1;end;
%if(n2>0)v2=v2/n2;end;
% if(n3>0)v3-v3/n3;end;
res.v1=v1;res.v2=v2;res.v3=v3;
res.n1=n1;res.n2=n2;res.n3=n3;

if(n1>0 && n2>0 && n3>0)
    res.deg=0;
else res.deg=1;
end;
%useful, dot parallel products.
dp1=left(1)*v1(1)+left(2)*v1(2)+left(3)*v1(3);
dp2=right(1)*v2(1)+right(2)*v2(2)+right(3)*v2(3);
dp3=base(1)*v3(1)+base(2)*v3(2)+base(3)*v3(3);
res.dp=[dp1,dp2,dp3];
n=zeros(3,3);
n(:,1)=n1;
n(:,2)=n2;
n(:,3)=n3;
res.n=n;
vx=[v1(1),v2(1),v3(1)];
vy=[v1(2),v2(2),v3(2)];
vz=[v1(3),v2(3),v3(3)];
cx=[coefs(1,2),coefs(1,3),coefs(1,1)];
cy=[coefs(2,2),coefs(2,3),coefs(2,1)];
cz=[coefs(3,2),coefs(3,3),coefs(3,1)];
res.vx=vx;res.vy=vy;res.vz=vz;
res.cx=cx;res.cy=cy;res.cz=cz;

A=zeros(3,4,3);
if(dp1==0) dp1=1;end;
if(dp2==0) dp2=1;end;
if(dp3==0) dp3=1;end;
dp=[dp1,dp2,dp3];

A(1,1,:)=((vx.*cx)./dp)';
A(1,2,:)=((vx.*cy)./dp)';
A(1,3,:)=((vx.*cz)./dp)';
A(1,4,:)=((vy.*x2(1).*cy+x2(1).*cz.*vz-vx.*cz.*x2(3)-vx.*x2(2).*cy)./dp)';
A(2,1,:)=((vy.*cx)./dp)';
A(2,2,:)=((vy.*cy)./dp)';
A(2,3,:)=((vy.*cz)./dp)';
A(2,4,:)=((-cx.*vy.*x2(1)+cx.*vx.*x2(2)+cz.*vz.*x2(2)-cz.*vy.*x2(3))./dp)';
A(3,1,:)=((vz.*cx)./dp)';
A(3,2,:)=((vz.*cy)./dp)';
A(3,3,:)=((vz.*cz)./dp)';
A(3,4,:)=((-vz.*cx.*x2(1)-vz.*x2(1).*cy+x2(3).*cx.*vx+vy.*x2(3).*cy)./dp)';
res.A=A;

function[r]=coords(x,tetr)
xn=[x(1),x(2),x(3),1]';
if(tetr.dp(1)~=0 && tetr.n1>0)
    r1=norm(tetr.A(:,:,1)*xn-tetr.origin')/tetr.n1;
else r1=0; end;
if(tetr.dp(2)~=0 && tetr.n2>0)
    r2=norm(tetr.A(:,:,2)*xn-tetr.origin')/tetr.n2;
else r2=0; end;
if(tetr.dp(3)~=0 && tetr.n3>0)
    r3=norm(tetr.A(:,:,3)*xn-tetr.origin')/tetr.n3;
else r3=0; end;
r=[r1,r2,r3];

%project point x on axis in tetrahedral coord system.
function[r]=project_on_axis(xs,num,tetr)
r=0;
x=xs(1);y=xs(2);z=xs(3);
if(num==1)
    n=tetr.n1;
    dp=tetr.dp(1);
    if(tetr.dp(1)<=0) return; end;
    vx=tetr.v1(1);
    vy=tetr.v1(2);
    vz=tetr.v1(3);
    cx=tetr.faces(1,2);
    cy=tetr.faces(2,2);
    cz=tetr.faces(3,2);
elseif(num==2)
    n=tetr.n2;
    dp=tetr.dp(2);
    if(tetr.dp(2)<=0) return; end;
    vx=tetr.v2(1);
    vy=tetr.v2(2);
    vz=tetr.v2(3);
    cx=tetr.faces(1,3);
    cy=tetr.faces(2,3);
    cz=tetr.faces(3,3);
else %num==3
    n=tetr.n3;
    dp=tetr.dp(3);
    if(tetr.dp(3)<=0) return; end;
    vx=tetr.v3(1);
    vy=tetr.v3(2);
    vz=tetr.v3(3);
    cx=tetr.faces(1,1);
    cy=tetr.faces(2,1);
    cz=tetr.faces(3,1);
end;
x0=tetr.origin(1);y0=tetr.origin(2);z0=tetr.origin(3);
xp=((vx*z+x0*vz-vx*z0)*cz+(vx*y+vy*x0-vx*y0)*cy+vx*cx*x)/dp;
yp=((z*vy+vz*y0-vy*z0)*cz+(x*vy-vy*x0+vx*y0)*cx+cy*y*vy)/dp;
zp=((-vz*y0+vz*y+vy*z0)*cy+(-x0*vz+vz*x+vx*z0)*cx+vz*cz*z)/dp;
r=norm([xp-x0,yp-y0,zp-z0])/n;
return;

function[res]=ev_plane_eq(x,eq)
res=eq(1)*x(1)+eq(2)*x(2)+eq(3)*x(3)+eq(4);

function[res]=is_inside_tetrahedron(x,tetr)
dscr=-1e-10;
if(tetr.deg~=0) res=0; return; end;
res=1;
for i=1:4
    if(ev_plane_eq(x,tetr.faces(:,i))<dscr)
        res=0; return;
    end;
end;

function[xr]=atb_l(x,sz_l,sz_u,nDim)
xr=x;
for i=1:nDim
    if(x(i)<sz_l(i)) xr(i)=sz_l(i); end;
    if(x(i)>sz_u(i)) xr(i)=sz_u(i);end;
end;

function[xr]=atb(x,sz,nDim)
xr=x;
for i=1:nDim
    if(x(i)<1) xr(i)=1; end;
    if(x(i)>sz(i)) xr(i)=sz(i);end;
end;

function[x_dest]=coord_transform(x_src,ts,td)
r1=project_on_axis(x_src,1,ts);
r2=project_on_axis(x_src,2,ts);
r3=project_on_axis(x_src,3,ts);
%r=coords(x_src,ts);
%nn=norm([r(1), r(2), r(3)]-[r1,r2,r3]);
%if(norm([r(1), r(2), r(3)]-[r1,r2,r3])>1e-6)
%    nn
%end;
x_dest=td.origin+td.v1*r1+td.v2*r2+td.v3*r3;
